from http.client import HTTPException
from fastapi import APIRouter
from app.models.execute_sql_request import ExecuteRequest
from app.models.query_request import QueryRequest
from app.services.connections import create_connection, get_connections
from app.services.internal_database_service import DatabaseService
from app.services.llm_service import LocalLLMConnector

router = APIRouter(
    prefix="/llmsql",
    tags=["SQL Generation"],
    responses={404: {"description": "Not found"}},
)
llm = LocalLLMConnector(model_name="mistral:7b-instruct", use_gpu=True)
db_service = DatabaseService()


@router.post("/generate_sql")
async def generate_sql(req: QueryRequest):
    """
    Generate SQL from a natural language instruction using the local LLM.
    This endpoint DOES NOT execute the SQL, it only returns it for review.
    """
    print("üîπ [STEP 1] Input received:", repr(req.user_input))

    try:
        # Ejecutar el LLM local
        llm_response = llm.run(req.user_input)
        print("üîπ [STEP 2] Raw LLM response type:", type(llm_response))
        print("üîπ [STEP 3] Raw LLM response content:", repr(llm_response))
    except Exception as e:
        print("‚ùå [ERROR] Exception while calling llm.run():", e)
        raise HTTPException(status_code=500, detail=f"Error in LLM: {str(e)}")

    # Validar que el resultado sea un dict
    if not isinstance(llm_response, dict):
        print("‚ö†Ô∏è [WARNING] LLM returned non-dict:", llm_response)
        raise HTTPException(status_code=400, detail="Invalid LLM response format")

    sql_code = llm_response.get("sql")
    explanation = llm_response.get("explanation")

    print("üîπ [STEP 4] SQL generated:", sql_code)
    print("üîπ [STEP 5] Explanation:", explanation)

    if not sql_code:
        print("‚ö†Ô∏è [WARNING] No SQL generated by LLM")
        raise HTTPException(status_code=400, detail="No SQL generated by LLM.")

    response = {
        "generated_sql": sql_code,
        "explanation": explanation,
        "preview": "Review this SQL before execution.",
    }

    print("‚úÖ [STEP 6] Final response to return:", response)
    return response


@router.post("/execute_sql")
def execute_sql(req: ExecuteRequest):
    """
    Execute a validated or user-approved SQL command on the connected database.
    """
    try:
        result = db_service.execute(req.sql)
        return {"executed_sql": req.sql, "result": result}
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
